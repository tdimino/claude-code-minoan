"""
Google Gemini API Client for Image Generation

Wrapper for the Gemini 2.5 Flash Image (Nano Banana) API.
"""

import os
import base64
import requests
from typing import Optional, Dict, Any
from io import BytesIO


# API key must be provided via environment variable or parameter
DEFAULT_API_KEY = None


class GeminiImageClient:
    """
    Client for Google Gemini 2.5 Flash Image API.

    Handles image generation and transformation using the Nano Banana model.
    """

    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize Gemini client.

        Args:
            api_key: Google Gemini API key. If not provided, uses DEFAULT_API_KEY
                    or falls back to GEMINI_API_KEY environment variable.
        """
        self.api_key = api_key or DEFAULT_API_KEY or os.getenv('GEMINI_API_KEY')

        if not self.api_key:
            raise ValueError(
                "No API key provided. Set GEMINI_API_KEY environment variable, "
                "pass api_key parameter, or use default key."
            )

        # Use Nano Banana Pro (Gemini 3 Pro Image) for higher quality
        # Falls back to Nano Banana (2.5 Flash) if Pro not available
        self.model = "gemini-3-pro-image-preview"
        self.endpoint = f"https://generativelanguage.googleapis.com/v1beta/models/{self.model}:generateContent"


    def generate_image(self, prompt: str) -> bytes:
        """
        Generate an image from a text prompt (text-to-image).

        Args:
            prompt: Text description of the image to generate

        Returns:
            Image data as bytes (PNG format)

        Raises:
            Exception: If API request fails
        """

        headers = {
            "x-goog-api-key": self.api_key,
            "Content-Type": "application/json"
        }

        payload = {
            "contents": [{
                "parts": [
                    {"text": prompt}
                ]
            }]
        }

        response = requests.post(self.endpoint, headers=headers, json=payload)

        if response.status_code != 200:
            raise Exception(
                f"Gemini API error (status {response.status_code}): {response.text}"
            )

        # Extract image from response
        try:
            data = response.json()
            candidates = data.get('candidates', [])

            if not candidates:
                raise Exception("No image generated by API")

            parts = candidates[0].get('content', {}).get('parts', [])

            # Find the inline_data part with image
            for part in parts:
                if 'inlineData' in part or 'inline_data' in part:
                    inline_data = part.get('inlineData') or part.get('inline_data')
                    base64_data = inline_data.get('data')

                    if base64_data:
                        return base64.b64decode(base64_data)

            raise Exception("No image data found in API response")

        except Exception as e:
            raise Exception(f"Failed to parse API response: {str(e)}")


    def transform_image(
        self,
        image_data: bytes,
        mime_type: str,
        prompt: str
    ) -> bytes:
        """
        Transform an image using a text prompt (image + text-to-image).

        This is the core method for photo-to-emoji conversion.

        Args:
            image_data: Input image as bytes
            mime_type: MIME type of input image (e.g., 'image/jpeg', 'image/png')
            prompt: Text description of desired transformation

        Returns:
            Transformed image data as bytes (PNG format)

        Raises:
            Exception: If API request fails
        """

        # Encode image to base64
        base64_image = base64.b64encode(image_data).decode('utf-8')

        headers = {
            "x-goog-api-key": self.api_key,
            "Content-Type": "application/json"
        }

        payload = {
            "contents": [{
                "parts": [
                    {"text": prompt},
                    {
                        "inline_data": {
                            "mime_type": mime_type,
                            "data": base64_image
                        }
                    }
                ]
            }]
        }

        response = requests.post(self.endpoint, headers=headers, json=payload)

        if response.status_code != 200:
            raise Exception(
                f"Gemini API error (status {response.status_code}): {response.text}"
            )

        # Extract image from response
        try:
            data = response.json()
            candidates = data.get('candidates', [])

            if not candidates:
                raise Exception("No image generated by API")

            parts = candidates[0].get('content', {}).get('parts', [])

            # Find the inline_data part with image
            for part in parts:
                if 'inlineData' in part or 'inline_data' in part:
                    inline_data = part.get('inlineData') or part.get('inline_data')
                    base64_data = inline_data.get('data')

                    if base64_data:
                        return base64.b64decode(base64_data)

            raise Exception("No image data found in API response")

        except Exception as e:
            raise Exception(f"Failed to parse API response: {str(e)}")


    def edit_image(
        self,
        image_data: bytes,
        mime_type: str,
        edit_prompt: str
    ) -> bytes:
        """
        Edit an existing image using a text prompt (iterative image editing).

        Use this for making modifications to already-generated images, such as:
        - "add a hat"
        - "make the background blue"
        - "add sunglasses"
        - "change it to black and white"

        Args:
            image_data: Input image as bytes (can be emoji, photo, or any image)
            mime_type: MIME type of input image (e.g., 'image/jpeg', 'image/png')
            edit_prompt: Text description of the edit to make

        Returns:
            Edited image data as bytes (PNG format)

        Raises:
            Exception: If API request fails
        """

        # Encode image to base64
        base64_image = base64.b64encode(image_data).decode('utf-8')

        headers = {
            "x-goog-api-key": self.api_key,
            "Content-Type": "application/json"
        }

        # Key difference: Explicitly request IMAGE output for editing
        payload = {
            "contents": [{
                "parts": [
                    {"text": edit_prompt},
                    {
                        "inline_data": {
                            "mime_type": mime_type,
                            "data": base64_image
                        }
                    }
                ]
            }],
            "generationConfig": {
                "responseModalities": ["TEXT", "IMAGE"]  # Request both text and image
            }
        }

        response = requests.post(self.endpoint, headers=headers, json=payload)

        if response.status_code != 200:
            raise Exception(
                f"Gemini API error (status {response.status_code}): {response.text}"
            )

        # Extract image from response
        try:
            data = response.json()
            candidates = data.get('candidates', [])

            if not candidates:
                raise Exception("No image generated by API")

            parts = candidates[0].get('content', {}).get('parts', [])

            # Find the inline_data part with image
            for part in parts:
                if 'inlineData' in part or 'inline_data' in part:
                    inline_data = part.get('inlineData') or part.get('inline_data')
                    base64_data = inline_data.get('data')

                    if base64_data:
                        return base64.b64decode(base64_data)

            raise Exception("No image data found in API response")

        except Exception as e:
            raise Exception(f"Failed to parse API response: {str(e)}")


    def compose_images(
        self,
        images: list[Dict[str, Any]],
        prompt: str
    ) -> bytes:
        """
        Compose multiple images into one using a text prompt (multi-image-to-image).

        Args:
            images: List of dicts with 'data' (bytes) and 'mime_type' (str) keys
            prompt: Text description of desired composition

        Returns:
            Composed image data as bytes (PNG format)

        Raises:
            Exception: If API request fails
        """

        headers = {
            "x-goog-api-key": self.api_key,
            "Content-Type": "application/json"
        }

        # Build parts list: text prompt + all images
        parts = [{"text": prompt}]

        for img in images:
            base64_image = base64.b64encode(img['data']).decode('utf-8')
            parts.append({
                "inline_data": {
                    "mime_type": img['mime_type'],
                    "data": base64_image
                }
            })

        payload = {
            "contents": [{
                "parts": parts
            }]
        }

        response = requests.post(self.endpoint, headers=headers, json=payload)

        if response.status_code != 200:
            raise Exception(
                f"Gemini API error (status {response.status_code}): {response.text}"
            )

        # Extract image from response
        try:
            data = response.json()
            candidates = data.get('candidates', [])

            if not candidates:
                raise Exception("No image generated by API")

            parts = candidates[0].get('content', {}).get('parts', [])

            # Find the inline_data part with image
            for part in parts:
                if 'inlineData' in part or 'inline_data' in part:
                    inline_data = part.get('inlineData') or part.get('inline_data')
                    base64_data = inline_data.get('data')

                    if base64_data:
                        return base64.b64decode(base64_data)

            raise Exception("No image data found in API response")

        except Exception as e:
            raise Exception(f"Failed to parse API response: {str(e)}")


if __name__ == "__main__":
    # Example usage
    client = GeminiImageClient()

    # Test text-to-image
    print("Testing text-to-image...")
    try:
        image_data = client.generate_image(
            "A simple, flat icon of a smiling coffee cup on a white background"
        )
        with open("/tmp/test_generated.png", "wb") as f:
            f.write(image_data)
        print(f"✓ Generated image saved to /tmp/test_generated.png")
    except Exception as e:
        print(f"✗ Error: {e}")

    # Test image transformation
    print("\nTesting image-to-image transformation...")
    try:
        # Load a test image
        with open("/tmp/test_input.jpg", "rb") as f:
            input_data = f.read()

        transformed_data = client.transform_image(
            image_data=input_data,
            mime_type="image/jpeg",
            prompt="Transform this into a classic emoji style: round, simplified, bold outlines"
        )

        with open("/tmp/test_transformed.png", "wb") as f:
            f.write(transformed_data)

        print(f"✓ Transformed image saved to /tmp/test_transformed.png")
    except Exception as e:
        print(f"✗ Error: {e}")
