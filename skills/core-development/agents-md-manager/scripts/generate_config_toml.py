#!/usr/bin/env python3
"""
Generate Codex config.toml files (global or project-scoped).

Usage:
    python3 generate_config_toml.py [--global | --project <path>] [options]

Options:
    --model MODEL              Model name (default: gpt-5-codex)
    --reasoning EFFORT         Reasoning effort: minimal|low|medium|high|xhigh
    --personality STYLE        Personality: none|friendly|pragmatic
    --sandbox MODE             Sandbox: read-only|workspace-write|danger-full-access
    --approval POLICY          Approval: untrusted|on-failure|on-request|never
    --trust-project PATH       Add a trusted project path
    --mcp NAME COMMAND ARGS    Add an MCP server (repeatable)
    --profile NAME KEY=VAL     Add a profile (repeatable)
    --merge                    Merge with existing config instead of overwriting
    --dry-run                  Print to stdout instead of writing

Output: config.toml file at the appropriate location.
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Any


def load_existing_config(config_path: Path) -> str | None:
    """Load existing config.toml content if it exists."""
    if config_path.exists():
        try:
            return config_path.read_text()
        except IOError:
            return None
    return None


def generate_core_section(args: argparse.Namespace) -> list[str]:
    """Generate core settings section."""
    lines = []
    lines.append(f'model = "{args.model}"')
    if args.reasoning:
        lines.append(f'model_reasoning_effort = "{args.reasoning}"')
    if args.personality:
        lines.append(f'personality = "{args.personality}"')
    if args.approval:
        lines.append(f'approval_policy = "{args.approval}"')
    if args.sandbox:
        lines.append(f'sandbox_mode = "{args.sandbox}"')
    return lines


def generate_project_trust(trusted_projects: list[str]) -> list[str]:
    """Generate project trust sections."""
    if not trusted_projects:
        return []
    lines = [""]
    for project_path in trusted_projects:
        resolved = str(Path(project_path).expanduser().resolve())
        lines.append(f'[projects."{resolved}"]')
        lines.append('trust_level = "trusted"')
        lines.append("")
    return lines


def generate_profiles(profiles: list[tuple[str, dict]]) -> list[str]:
    """Generate profile sections."""
    if not profiles:
        return []
    lines = [""]
    for name, settings in profiles:
        lines.append(f"[profiles.{name}]")
        for key, val in settings.items():
            if isinstance(val, str):
                lines.append(f'{key} = "{val}"')
            elif isinstance(val, bool):
                lines.append(f"{key} = {'true' if val else 'false'}")
            elif isinstance(val, (int, float)):
                lines.append(f"{key} = {val}")
        lines.append("")
    return lines


def generate_mcp_servers(mcp_servers: list[dict]) -> list[str]:
    """Generate MCP server sections."""
    if not mcp_servers:
        return []
    lines = [""]
    for server in mcp_servers:
        name = server["name"]
        lines.append(f"[mcp_servers.{name}]")
        if "command" in server:
            lines.append(f'command = "{server["command"]}"')
        if "args" in server:
            args_str = ", ".join(f'"{a}"' for a in server["args"])
            lines.append(f"args = [{args_str}]")
        if "url" in server:
            lines.append(f'url = "{server["url"]}"')
        if "env" in server:
            env_items = ", ".join(f'{k} = "{v}"' for k, v in server["env"].items())
            lines.append(f"env = {{ {env_items} }}")
        lines.append("enabled = true")
        lines.append("required = false")
        lines.append("")
    return lines


def generate_sandbox_settings(sandbox_mode: str | None, writable_roots: list[str] | None) -> list[str]:
    """Generate sandbox configuration."""
    if sandbox_mode != "workspace-write":
        return []
    lines = ["", "[sandbox_workspace_write]"]
    if writable_roots:
        roots_str = ", ".join(f'"{r}"' for r in writable_roots)
        lines.append(f"writable_roots = [{roots_str}]")
    lines.append("network_access = false")
    lines.append("")
    return lines


def generate_agents_md_discovery() -> list[str]:
    """Generate AGENTS.md discovery settings."""
    return [
        "",
        "# AGENTS.md Discovery",
        "project_doc_max_bytes = 32768",
        'project_root_markers = [".git", ".hg"]',
        "",
    ]


def generate_config(args: argparse.Namespace) -> str:
    """Generate complete config.toml content."""
    lines = ["# Codex CLI Configuration", f"# Generated by agents-md-manager", ""]

    # Core settings
    lines.extend(generate_core_section(args))

    # Project trust
    if args.trust_project:
        lines.extend(generate_project_trust(args.trust_project))

    # Profiles
    if args.profiles:
        parsed_profiles = []
        for profile_spec in args.profiles:
            parts = profile_spec.split(maxsplit=1)
            name = parts[0]
            settings = {}
            if len(parts) > 1:
                for pair in parts[1].split(","):
                    pair = pair.strip()
                    if "=" in pair:
                        k, v = pair.split("=", 1)
                        settings[k.strip()] = v.strip()
            parsed_profiles.append((name, settings))
        lines.extend(generate_profiles(parsed_profiles))

    # MCP servers
    if args.mcp:
        mcp_servers = []
        for mcp_spec in args.mcp:
            parts = mcp_spec.split(maxsplit=2)
            server = {"name": parts[0]}
            if len(parts) > 1:
                server["command"] = parts[1]
            if len(parts) > 2:
                server["args"] = parts[2].split()
            mcp_servers.append(server)
        lines.extend(generate_mcp_servers(mcp_servers))

    # Sandbox
    lines.extend(generate_sandbox_settings(args.sandbox, getattr(args, "writable_roots", None)))

    # AGENTS.md discovery
    lines.extend(generate_agents_md_discovery())

    # History
    lines.extend([
        "[history]",
        'persistence = "save-all"',
        "",
    ])

    return "\n".join(lines)


def merge_configs(existing: str, generated: str) -> str:
    """Merge generated config into existing, preserving existing values.

    Uses line-level deduplication: existing keys and section headers are preserved,
    new keys and sections from the generated config are appended.
    """
    existing_lines = existing.splitlines()
    existing_stripped = {line.strip() for line in existing_lines}

    # Collect existing top-level keys (outside sections)
    existing_keys = set()
    for line in existing_lines:
        stripped = line.strip()
        if "=" in stripped and not stripped.startswith("#") and not stripped.startswith("["):
            key = stripped.split("=", 1)[0].strip()
            existing_keys.add(key)

    # Collect existing section headers (exact match)
    existing_sections = set()
    for line in existing_lines:
        stripped = line.strip()
        if stripped.startswith("[") and stripped.endswith("]"):
            existing_sections.add(stripped)

    merged_lines = list(existing_lines)
    skip_section = False
    for line in generated.splitlines():
        stripped = line.strip()

        # Skip comments and blank lines that would be redundant
        if not stripped or stripped.startswith("#"):
            if not skip_section:
                merged_lines.append(line)
            continue

        # Section headers: skip entire section if it already exists
        if stripped.startswith("["):
            if stripped in existing_sections:
                skip_section = True
                continue
            else:
                skip_section = False
                merged_lines.append(line)
                continue

        if skip_section:
            continue

        # Key-value lines: skip if key already exists
        if "=" in stripped and not stripped.startswith("["):
            key = stripped.split("=", 1)[0].strip()
            if key in existing_keys:
                continue

        merged_lines.append(line)

    return "\n".join(merged_lines)


def determine_output_path(args: argparse.Namespace) -> Path:
    """Determine where to write config.toml."""
    if args.scope == "global":
        codex_home = Path(os.environ.get("CODEX_HOME", Path.home() / ".codex"))
        return codex_home / "config.toml"
    elif args.project_path:
        project = Path(args.project_path)
        codex_dir = project / ".codex"
        codex_dir.mkdir(exist_ok=True)
        return codex_dir / "config.toml"
    else:
        return Path.cwd() / ".codex" / "config.toml"


def main():
    parser = argparse.ArgumentParser(description="Generate Codex config.toml")
    scope = parser.add_mutually_exclusive_group()
    scope.add_argument("--global", dest="scope", action="store_const", const="global",
                       help="Generate global ~/.codex/config.toml")
    scope.add_argument("--project", dest="project_path", metavar="PATH",
                       help="Generate project-scoped .codex/config.toml at PATH")
    parser.add_argument("--model", default="gpt-5-codex", help="Model name")
    parser.add_argument("--reasoning", choices=["minimal", "low", "medium", "high", "xhigh"],
                        help="Reasoning effort")
    parser.add_argument("--personality", choices=["none", "friendly", "pragmatic"],
                        help="Communication style")
    parser.add_argument("--sandbox", choices=["read-only", "workspace-write", "danger-full-access"],
                        help="Sandbox mode")
    parser.add_argument("--approval", choices=["untrusted", "on-failure", "on-request", "never"],
                        help="Approval policy")
    parser.add_argument("--trust-project", action="append", help="Trusted project path (repeatable)")
    parser.add_argument("--mcp", action="append", help="MCP server: 'name command args...' (repeatable)")
    parser.add_argument("--profiles", action="append",
                        help="Profile: 'name key=val,key=val' (repeatable)")
    parser.add_argument("--merge", action="store_true", help="Merge with existing config")
    parser.add_argument("--dry-run", action="store_true", help="Print to stdout, don't write")

    args = parser.parse_args()
    if not args.scope and not args.project_path:
        args.scope = "global"

    config_content = generate_config(args)
    output_path = determine_output_path(args)

    if args.merge:
        existing = load_existing_config(output_path)
        if existing:
            config_content = merge_configs(existing, config_content)

    if args.dry_run:
        print(config_content)
        report = {"action": "dry-run", "output_path": str(output_path),
                  "lines": len(config_content.splitlines())}
    else:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(config_content)
        report = {"action": "written", "output_path": str(output_path),
                  "lines": len(config_content.splitlines()),
                  "bytes": len(config_content.encode("utf-8"))}

    print(json.dumps(report, indent=2), file=sys.stderr)


if __name__ == "__main__":
    main()
