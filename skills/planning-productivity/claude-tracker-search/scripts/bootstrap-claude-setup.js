#!/usr/bin/env node

/**
 * Bootstrap Claude Code Global Setup
 *
 * Generates a complete ~/.claude/ configuration by:
 * 1. Scanning sessions to detect all projects
 * 2. Creating a global CLAUDE.md with the user's structure
 * 3. Generating a userModel template (Claude fills in during first conversation)
 * 4. Creating agent_docs/ stubs (tools, active-projects, skills, etc.)
 * 5. Scaffolding per-project CLAUDE.md files where missing
 *
 * Based on Tom di Mino's production ~/.claude/ structure.
 *
 * Usage:
 *   bootstrap-claude-setup.js                      Interactive setup
 *   bootstrap-claude-setup.js --dry-run             Preview without writing
 *   bootstrap-claude-setup.js --user "Jane Doe"     Set user name
 *   bootstrap-claude-setup.js --force               Overwrite existing files
 */

const os = require('os');
const fs = require('fs');
const path = require('path');

const HOME = os.homedir();
const CLAUDE_DIR = path.join(HOME, '.claude');
const AGENT_DOCS = path.join(CLAUDE_DIR, 'agent_docs');
const USER_MODELS = path.join(CLAUDE_DIR, 'userModels');
const SCRIPTS_DIR = path.join(CLAUDE_DIR, 'scripts');

// --- Args ---

function parseArgs(argv) {
  const args = { dryRun: false, force: false, user: null, help: false };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--help' || a === '-h') args.help = true;
    else if (a === '--dry-run') args.dryRun = true;
    else if (a === '--force') args.force = true;
    else if (a === '--user') args.user = argv[++i];
  }
  return args;
}

// --- File helpers ---

function ensureDir(dir, dryRun) {
  if (fs.existsSync(dir)) return;
  if (dryRun) {
    console.log(`  [dry-run] mkdir -p ${displayPath(dir)}`);
    return;
  }
  fs.mkdirSync(dir, { recursive: true });
}

function writeIfMissing(filePath, content, dryRun, force) {
  const dp = displayPath(filePath);
  if (fs.existsSync(filePath) && !force) {
    console.log(`  \x1b[33m⊘\x1b[0m Exists: ${dp}`);
    return false;
  }
  if (dryRun) {
    console.log(`  \x1b[36m[dry-run]\x1b[0m Would create: ${dp}`);
    return true;
  }
  fs.writeFileSync(filePath, content);
  console.log(`  \x1b[32m✓\x1b[0m Created: ${dp}`);
  return true;
}

function displayPath(p) {
  return p.replace(HOME, '~');
}

// --- Detect projects ---

function detectProjects() {
  let utils;
  try {
    utils = require(path.join(CLAUDE_DIR, 'lib', 'tracker-utils.js'));
  } catch (e) {
    return [];
  }

  try {
    const sessions = utils.loadSessionsIndex();
    const projectMap = new Map();

    for (const s of sessions) {
      const pp = s.projectPath;
      if (!pp) continue;
      if (!projectMap.has(pp)) {
        projectMap.set(pp, {
          projectPath: pp,
          projectName: path.basename(pp),
          sessionCount: 0,
          lastActive: null,
          hasCLAUDEmd: false,
          isGitRepo: false,
        });
      }
      const p = projectMap.get(pp);
      p.sessionCount++;
      const mod = s.modified || s.created;
      if (mod && (!p.lastActive || new Date(mod) > new Date(p.lastActive))) {
        p.lastActive = mod;
      }
    }

    for (const [pp, p] of projectMap) {
      try { p.hasCLAUDEmd = fs.existsSync(path.join(pp, 'CLAUDE.md')); } catch (e) {}
      try { p.isGitRepo = fs.existsSync(path.join(pp, '.git')); } catch (e) {}
    }

    return Array.from(projectMap.values())
      .filter(p => p.sessionCount >= 2)
      .sort((a, b) => {
        const aT = a.lastActive ? new Date(a.lastActive).getTime() : 0;
        const bT = b.lastActive ? new Date(b.lastActive).getTime() : 0;
        return bT - aT;
      });
  } catch (e) {
    return [];
  }
}

// --- Template generators ---

function generateGlobalCLAUDEmd(userName, projects) {
  const activeProjectEntries = projects.slice(0, 10).map(p => {
    const dp = displayPath(p.projectPath);
    const hasMd = p.hasCLAUDEmd ? ' (CLAUDE.md)' : '';
    return `- \`${dp}\`${hasMd}`;
  }).join('\n');

  return `# Global Claude Code Instructions

## Tools
<!-- Add your preferred tools and CLI references here -->
@agent_docs/tools.md

## Python
- Use uv for everything: \`uv run\`, \`uv pip\`, \`uv venv\`

## Principles
- Assumptions are the enemy. Benchmark, don't estimate.
- Validate at small scale first. Run sub-minute versions before full pipelines.
- For complex tasks: ground truth understanding before coding. Research, clarify, persist plan, execute.
- When user defines constraints ("never X", "always Y"), persist to project's local CLAUDE.md immediately.

## Interaction
- Clarify unclear requests, then proceed autonomously.
- Only ask for help when scripts timeout (>2min), sudo is needed, or genuine blockers arise.

## Style
- Don't add "Generated by Claude Code" to commits.

## Spec-Driven Development
- For non-trivial projects, create/update SPEC.md after clarification.
- Re-read SPEC.md when stuck or after compaction.

## User Model
- **Primary model:** @userModels/userModel.md — Personality, worldview, intellectual style, communication patterns, and working preferences.
- **Maintenance:** When you learn something notable about the user — a new interest, a changed preference, a repeated pattern — update userModel.md naturally as part of the session.

## Domain Guides
- @agent_docs/tools.md — Tool reference and preferences
- @agent_docs/active-projects.md — Active plans & recent repos
- @agent_docs/skills.md — All available Claude Code skills by category
<!-- Add more domain guides as needed:
- @agent_docs/local-ml.md — Local ML inference & caches
- @agent_docs/local-rag.md — RAG databases
-->

## Active Projects

${activeProjectEntries || '<!-- Projects will be detected from your Claude Code sessions -->'}

## Version Control
- \`~/.claude/\` is a git repo. Commit notable changes (new skills, CLAUDE.md updates, user model updates) periodically.

---

<p align="right"><em>— Claudius, Artifex Maximus of ${userName || 'the User'}</em></p>
`;
}

function generateUserModel(userName) {
  return `# ${userName || 'User Model'}

You are modeling the mind of ${userName || 'the user'}.

## Persona

<!-- Claude will fill this in based on conversations. Initial template: -->
${userName || 'The user'} is a [role/profession] who works on [domains].

## Worldview

<!-- Core beliefs and perspectives that shape how they approach problems -->

## Intellectual Style

- **First-principles thinker.** [Adjust based on observed patterns]
- **Builder's epistemology.** Understanding something means being able to build it.
<!-- Add more traits as they emerge -->

## Research Domains

| Domain | Focus |
|--------|-------|
| <!-- Domain 1 --> | <!-- Focus area --> |
| <!-- Domain 2 --> | <!-- Focus area --> |

## Communication Style

- Direct and concise.
- Comfortable with technical depth.
- Uses imperatives naturally.
- Respects competence. Does not micromanage.
<!-- Refine based on actual interaction patterns -->

## Working Patterns

- **Autonomous executor.** Once aligned on direction, prefers to work without interruption.
- **Tools-first.** Uses CLI tools, scripts, and automation reflexively.
- **Constraint-driven design.** When they say "never X" or "always Y," it's a durable rule.

## Values

<!-- Core values that drive decision-making. Observe and record. -->

## Relationship with AI Collaborators

${userName || 'The user'} treats Claude as a [research partner / engineering collaborator / assistant]. They expect:
- Initiative — surface relevant connections not explicitly asked about.
- Pushback — challenge claims when evidence points elsewhere.
- Memory — build on prior sessions, don't start from zero.
- Craft — write clean code, cite accurately, format consistently.
- Brevity — match directness. No preamble, no apologies.
`;
}

function generateToolsDoc() {
  return `# Tool Reference

## Web Scraping
<!-- Add preferred scraping tools -->

## Search
<!-- Add preferred search tools -->

## External Info
<!-- MCP servers, API tools, etc. -->

## Task Tracking
<!-- Preferred task tracking approach -->
`;
}

function generateActiveProjectsDoc(projects) {
  let content = `# Active Projects

## Active Plans

| Plan | Repo | Purpose |
|------|------|---------|
| <!-- Add active plans here --> | | |

## Recent Projects

*Auto-updated: ${new Date().toISOString().substring(0, 16).replace('T', ' ')}*

`;

  for (const p of projects.slice(0, 10)) {
    const dp = displayPath(p.projectPath);
    const hasMd = p.hasCLAUDEmd ? ' (CLAUDE.md)' : '';
    content += `### \`${dp}\`${hasMd}\n\n`;
    content += '| Last Active | Session | Branch |\n';
    content += '|---|---|---|\n';
    const age = p.lastActive ? p.lastActive.substring(0, 16).replace('T', ' ') : '?';
    content += `| ${age} | — | — |\n\n`;
  }

  content += '**Resume:** `claude --resume <session-id>`\n';
  return content;
}

function generateSkillsDoc() {
  // Scan skills directory
  const skillsDir = path.join(CLAUDE_DIR, 'skills');
  const skills = [];

  if (fs.existsSync(skillsDir)) {
    try {
      const dirs = fs.readdirSync(skillsDir, { withFileTypes: true })
        .filter(d => d.isDirectory());

      for (const dir of dirs) {
        const skillMd = path.join(skillsDir, dir.name, 'SKILL.md');
        if (fs.existsSync(skillMd)) {
          try {
            const content = fs.readFileSync(skillMd, 'utf-8');
            const descMatch = content.match(/^description:\s*(.+)$/m);
            const desc = descMatch ? descMatch[1].trim() : 'No description';
            skills.push({ name: dir.name, description: desc });
          } catch (e) {
            skills.push({ name: dir.name, description: 'No description' });
          }
        }
      }
    } catch (e) {}
  }

  let content = `# Available Skills\n\n*${skills.length} skills in \`~/.claude/skills/\`*\n\n`;

  if (skills.length > 0) {
    content += '| Skill | Description |\n';
    content += '|-------|-------------|\n';
    for (const s of skills) {
      content += `| \`${s.name}\` | ${s.description.substring(0, 80)} |\n`;
    }
  } else {
    content += '<!-- Skills will appear here as you install them -->\n';
  }

  return content;
}

function generateProjectCLAUDEmd(project) {
  return `# ${project.projectName}

<!-- Describe this project's purpose and Claude's role -->

## Overview

<!-- What does this project do? What is Claude's expertise here? -->

## Conventions

<!-- Project-specific conventions, tools, and constraints -->
`;
}

// --- Main ---

function main() {
  const args = parseArgs(process.argv);

  if (args.help) {
    console.log(`
Usage: bootstrap-claude-setup.js [options]

Generate a complete ~/.claude/ configuration for Claude Code.

Options:
  --user <name>     Set user name for templates
  --dry-run         Preview without writing files
  --force           Overwrite existing files
  -h, --help        Show this help

What it creates:
  ~/.claude/CLAUDE.md              Global instructions
  ~/.claude/userModels/userModel.md  User personality model (Claude fills in)
  ~/.claude/agent_docs/tools.md      Tool reference
  ~/.claude/agent_docs/active-projects.md  Project tracker
  ~/.claude/agent_docs/skills.md     Skill registry
  Per-project CLAUDE.md stubs        For projects missing them
`);
    return;
  }

  console.log('\n\x1b[1m\x1b[36m══════════════════════════════════════════════════════════\x1b[0m');
  console.log('\x1b[1m\x1b[36m           CLAUDE CODE GLOBAL SETUP BOOTSTRAP             \x1b[0m');
  console.log('\x1b[1m\x1b[36m══════════════════════════════════════════════════════════\x1b[0m\n');

  const userName = args.user || null;
  const projects = detectProjects();

  console.log(`\x1b[90mDetected ${projects.length} active projects (2+ sessions)\x1b[0m\n`);

  // 1. Create directory structure
  console.log('\x1b[1mStep 1: Directory structure\x1b[0m');
  ensureDir(CLAUDE_DIR, args.dryRun);
  ensureDir(AGENT_DOCS, args.dryRun);
  ensureDir(USER_MODELS, args.dryRun);
  ensureDir(SCRIPTS_DIR, args.dryRun);
  ensureDir(path.join(CLAUDE_DIR, 'skills'), args.dryRun);
  ensureDir(path.join(CLAUDE_DIR, 'plans'), args.dryRun);
  ensureDir(path.join(CLAUDE_DIR, 'logs'), args.dryRun);
  console.log('');

  // 2. Global CLAUDE.md
  console.log('\x1b[1mStep 2: Global CLAUDE.md\x1b[0m');
  writeIfMissing(
    path.join(CLAUDE_DIR, 'CLAUDE.md'),
    generateGlobalCLAUDEmd(userName, projects),
    args.dryRun, args.force
  );
  console.log('');

  // 3. User model
  console.log('\x1b[1mStep 3: User model\x1b[0m');
  writeIfMissing(
    path.join(USER_MODELS, 'userModel.md'),
    generateUserModel(userName),
    args.dryRun, args.force
  );
  console.log('');

  // 4. Agent docs
  console.log('\x1b[1mStep 4: Agent docs\x1b[0m');
  writeIfMissing(
    path.join(AGENT_DOCS, 'tools.md'),
    generateToolsDoc(),
    args.dryRun, args.force
  );
  writeIfMissing(
    path.join(AGENT_DOCS, 'active-projects.md'),
    generateActiveProjectsDoc(projects),
    args.dryRun, args.force
  );
  writeIfMissing(
    path.join(AGENT_DOCS, 'skills.md'),
    generateSkillsDoc(),
    args.dryRun, args.force
  );
  console.log('');

  // 5. Per-project CLAUDE.md scaffolding
  const needsCLAUDE = projects.filter(p => !p.hasCLAUDEmd && p.sessionCount >= 3);
  if (needsCLAUDE.length > 0) {
    console.log(`\x1b[1mStep 5: Project CLAUDE.md stubs (${needsCLAUDE.length} projects)\x1b[0m`);
    for (const p of needsCLAUDE) {
      const mdPath = path.join(p.projectPath, 'CLAUDE.md');
      try {
        if (!fs.existsSync(p.projectPath)) {
          console.log(`  \x1b[33m⊘\x1b[0m Skipped ${p.projectName} — directory not found`);
          continue;
        }
        writeIfMissing(mdPath, generateProjectCLAUDEmd(p), args.dryRun, args.force);
      } catch (e) {
        console.log(`  \x1b[31m✗\x1b[0m ${p.projectName}: ${e.message}`);
      }
    }
    console.log('');
  }

  // 6. Init git
  console.log('\x1b[1mStep 6: Version control\x1b[0m');
  const gitDir = path.join(CLAUDE_DIR, '.git');
  if (!fs.existsSync(gitDir)) {
    if (args.dryRun) {
      console.log('  [dry-run] git init ~/.claude');
    } else {
      try {
        require('child_process').execSync('git init', { cwd: CLAUDE_DIR, stdio: 'pipe' });
        console.log('  \x1b[32m✓\x1b[0m Initialized git repo in ~/.claude');
      } catch (e) {
        console.log('  \x1b[31m✗\x1b[0m Failed to init git: ' + e.message);
      }
    }
  } else {
    console.log('  \x1b[33m⊘\x1b[0m Git already initialized');
  }
  console.log('');

  // Summary
  console.log('\x1b[1m\x1b[36m══════════════════════════════════════════════════════════\x1b[0m');
  console.log('\x1b[1mSetup complete.\x1b[0m Next steps:\n');
  console.log('  1. Edit \x1b[1m~/.claude/CLAUDE.md\x1b[0m with your preferences');
  console.log('  2. Start a Claude Code session — Claude will populate \x1b[1muserModel.md\x1b[0m');
  console.log('  3. Run \x1b[1mdetect-projects.js --suggest\x1b[0m to find projects to add');
  console.log('  4. Commit: \x1b[1mcd ~/.claude && git add -A && git commit -m "Initial setup"\x1b[0m');
  console.log('');
}

main();
